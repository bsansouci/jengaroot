
open Core.Std
open Jenga_lib.Api

let ( *>>= ) = Dep.bind
let ( *>>| ) = Dep.map
let relative = Path.relative

module Alias = struct
  include Alias
  let default ~dir = Alias.create ~dir "DEFAULT"
end

(* try new coding style: pass the current [dir] via functor arg *)
module F(X : sig val dir : Path.t end) = struct
  open X

  let makefile_basename = "Makefile.extracted-from-jenga"

  let keep path =
    not (Path.basename path = makefile_basename) (* avoid sillyness *)
    && (
      Path.is_descendant ~dir path
      || Path.is_descendant ~dir:(Path.root_relative ".liblinks") path
      || Path.is_descendant ~dir:(Path.root_relative ".ppx") path
    )

  let wrap_relative_cd_from path s =
    if dir = path then s else
      let relative_cd = Path.reach_from ~dir path in
      sprintf "(cd %s; %s)" relative_cd s

  let format_path = Path.reach_from ~dir
  let format_paths xs = String.concat ~sep:" " (List.map xs ~f:format_path)

  let format_trip {Reflected.Trip.deps;targets;action} =
    let deps = List.filter deps ~f:keep in
    let targets = List.filter targets ~f:keep in
    let action_string =
      wrap_relative_cd_from (Reflected.Action.dir action)
        (Reflected.Action.string_for_one_line_make_recipe_ignoring_dir action)
    in
    match targets with
    | [] -> sprintf "#rule with no targets!"
    | t1::rest ->
      let touch_string =
        match rest with | [] -> "" | _ ->
          sprintf "\n\ttouch %s"
            (String.concat ~sep:" " (List.map rest ~f:format_path))
      in
      String.concat (List.map rest ~f:(fun target ->
        sprintf "%s : %s\n" (format_path target) (format_path t1)
      )) ^ sprintf "%s : %s\n\t%s%s"
        (format_path t1) (format_paths deps) action_string touch_string


  let banner = "
# This Makefile was generated by jenga.

# Note: make doesn't properly support multi-target rules, so we do the best we can.
# The makefile should work when building from clean, and incremental builds, following
# source files changes. Incremental builds following selected removal of generated files
# is likely to fail.
"

  let format_putenv xs =
    String.concat ~sep:"\n" (List.map xs ~f:(fun (k,v) ->
      match v with 
      | Some vv -> sprintf "export %s := %s" k vv
      | None -> sprintf "(* export %s := None *)" k))

  let start_all =
    sprintf "
.PHONY: start all
start:\n\tcd $$(pwd -P) && $(MAKE) all # cd to physical path
"

  (* not suitable for comparison in general, since it equates too many things *)
  let compare_trip_for_sort =
    (* Trying to compare in a way that equates path/lib__Foo and path/foo. We can just
       compare paths when we don't care about comparing packing vs wrapping anymore.*)
    let normalize_basename s =
      match String.substr_index s ~pattern:"__" with
      | None -> s
      | Some i -> String.uncapitalize (String.drop_prefix s (i + 2))
    in
    let key_of_trip (trip : Reflected.Trip.t) =
      List.map trip.targets ~f:(fun p ->
        Path.to_string (Path.dirname p), normalize_basename (Path.basename p))
    in
    fun trip1 trip2 ->
      [%compare: (string * string) list]
        (key_of_trip trip1)
        (key_of_trip trip2)
  ;;

  let format_makefile ~putenv ~roots trips =
    let trips = List.sort trips ~cmp:compare_trip_for_sort in
    sprintf "%s\n%s\n%s\nall : %s\n\n%s\n"
      banner
      (format_putenv putenv)
      start_all
      (format_paths roots)
      (String.concat ~sep:"\n\n" (List.map trips ~f:format_trip))

  let rule =
    let makefile = relative ~dir makefile_basename in
    [
      Rule.create ~targets:[makefile] (
        Reflect.putenv *>>= fun putenv ->
        Reflect.alias (Alias.default ~dir) *>>= fun roots ->
        let roots = List.filter roots ~f:(fun r -> not (r = makefile)) in
        Reflect.reachable ~keep roots *>>| fun trips ->
        Action.save (format_makefile ~putenv ~roots trips) ~target:makefile
      );
      (*Rule.default ~dir [Dep.path makefile];*)
    ]

end

let extract ~dir =
  let module M = F (struct let dir = dir end) in
  M.rule
