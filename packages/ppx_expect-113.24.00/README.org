* EXPECT-TEST - Cram like framework for OCaml

** Introduction

Expect-test is a framework for writing tests in OCaml, similar to [[https://bitheap.org/cram/][Cram]].
Expect-tests mimic the existing inline tests framework with the =let%expect_test= construct.
The body of an expect-test can contain output-generating code, interleaved with =%expect= extension 
expressions to denote the expected output.

When run, these tests will pass iff the output matches what was expected. If a test fails, a 
corrected file with the suffix ".corrected" will be produced with the actual output, and the 
=inline_tests_runner= will output a diff.

Here is an example Expect-test program, say in =foo.ml=

#+begin_src ocaml
open Core.Std

let%expect_test "addition" =
  printf "%d" (1 + 2);
  [%expect {| 4 |}]
#+end_src

When the test is run (as part of =inline_tests_runner=), =foo.ml.corrected= will be produced with the 
contents:

#+begin_src ocaml
open Core.Std

let%expect_test "addition" =
  printf "%d" (1 + 2);
  [%expect {| 3 |}]
#+end_src

=inline_tests_runner= will also output the diff:

: ---foo.ml
: +++foo.ml.corrected
: File "foo.ml", line 5, characters 0-1:
:   open Core.Std
:     
:   let%expect_test "addition" =
:     printf "%d" (1 + 2);
: -|  [%expect {| 4 |}]
: +|  [%expect {| 3 |}]

Diffs will be shown in color if the =-use-color= flag is passed to the test runner executable.

** Matching, globs, and regexps

Matching is done on a line-by-line basis. If any output line fails to
match its expected output, the expected line is replaced with the
actual line in the final output.

Lines can end with a "tag" indicating the kind of match to perform.

The =(regexp)= tag will perform regexp matching on the given line:

#+begin_src ocaml
printf "foo";
[%expect {| foo\|bar (regexp) |}]
#+end_src

Similarly, the =(glob)= tag will perform glob matching on the given line:

#+begin_src ocaml
printf "foobarbaz";
[%expect {| {foo,hello}* (glob) |}]
#+end_src

The =(literal)= tag will force a literal match on a line, and can be useful in edge cases:

#+begin_src ocaml
printf "foo*bar (regexp)";
[%expect {| foo*bar (regexp) (literal) |}]
#+end_src

The =(escaped)= tag will treat the line as an escaped literal string, which can be useful 
for matching unprintable characters. It doesn't support escaped newlines right now.

If there's no tag is specified, a literal match is expected.

*** Whitespace

If an =%expect= node starts with a line break, it is stripped.
The rest of the lines can be indented by any amount; the amount of indentation is decided by
the minimum indentation on any given line. Extra whitespace after the indentation is 
considered part of the expected output.

All leading/trailing whitespace on single-line expectations is ignored.

** Comparing Expect-test and unit testing (e.g. =let%test_unit=)

The simple example above can be easily represented as a unit test:

#+begin_src ocaml
let%test_unit "addition" = [%test_result: int] (1 + 2) ~expect:4
#+end_src

So, why would one use Expect-test rather than a unit test?  There are
several differences between the two approaches.

With a unit test, one must write code that explicitly checks that the
actual behavior agrees with the expected behavior.  =%test_result= is
often a convenient way of doing that, but even using that requires:

- creating a value to compare
- writing the type of that value
- having a comparison function on the value
- writing down the expected value

With Expect-test, we can simply add print statements whose output gives
insight into the behavior of the program, and blank =%expect=
attributes to collect the output.  We then run the program to see if
the output is acceptable, and if so, *replace* the original program
with its output.  E.g we might first write our program like this:

#+begin_src ocaml
let%expect_test _ =
  printf "%d" (1 + 2);
  [%expect {||}]
#+end_src

The corrected file would contain:

#+begin_src ocaml
let%expect_test _ =
  printf "%d" (1 + 2);
  [%expect {| 3 |}]
#+end_src

With Expect-test, we only have to write code that prints things that we
care about.  We don't have to construct expected values or write code
to compare them.  We get comparison for free by using diff on the
output.  And a good diff (e.g. patdiff) can make understanding
differences between large outputs substantially easier, much easier
than typical unit-testing code that simply states that two values
aren't equal.

Once an Expect-test program produces the desired expected output and we
have replaced the original program with its output, we now
automatically have a regression test going forward.  Any undesired
change to the output will lead to a mismatch between the source
program and its output.

With Expect-test, the source program and its output are interleaved.  This
makes debugging easier, because we do not have to jump between source
and its output and try to line them up.  Furthermore, when there is a
mismatch, we can simply add print statements to the source program and
run it again.  This gives us interleaved source and output with the
debug messages interleaved in the right place.  We might even insert
additional empty =%%expect= attributes to collect debug messages.

** Implementation

Every =%expect= node in an Expect-test program becomes a point at which
the program output is captured. Once the program terminates, the
captured outputs are matched against the expected outputs, and interleaved with 
the original source code to produce the corrected file. Trailing output is appended in a 
new =%expect= node.
